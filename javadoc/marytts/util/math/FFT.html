<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_60) on Mon Dec 21 23:35:34 CET 2015 -->
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
<title>FFT (MaryTTS 5.2-beta1 API)</title>
<meta name="date" content="2015-12-21">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="FFT (MaryTTS 5.2-beta1 API)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/FFT.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../marytts/util/math/DTW.RecurssiveDTW.html" title="class in marytts.util.math"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../marytts/util/math/FFTMixedRadix.html" title="class in marytts.util.math"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?marytts/util/math/FFT.html" target="_top">Frames</a></li>
<li><a href="FFT.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">marytts.util.math</div>
<h2 title="Class FFT" class="title">Class FFT</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>marytts.util.math.FFT</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="strong">FFT</span>
extends <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></pre>
<dl><dt><span class="strong">Author:</span></dt>
  <dd>Marc Schr&ouml;der</dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../../marytts/util/math/FFT.html#FFT()">FFT</a></strong>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#autoCorrelate(double[])">autoCorrelate</a></strong>(double[]&nbsp;signal)</code>
<div class="block">Compute the autocorrelation of a signal, by inverse transformation of its power spectrum.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#autoCorrelateWithZeroPadding(double[])">autoCorrelateWithZeroPadding</a></strong>(double[]&nbsp;signal)</code>
<div class="block">Compute the autocorrelation of a signal, by inverse transformation of its power spectrum.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#computeAmplitudeSpectrum_FD(double[])">computeAmplitudeSpectrum_FD</a></strong>(double[]&nbsp;fft)</code>
<div class="block">From the result of the FFT (in the frequency domain), compute the absolute value for each positive frequency, i.e.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#computeAmplitudeSpectrum(double[])">computeAmplitudeSpectrum</a></strong>(double[]&nbsp;signal)</code>
<div class="block">Convenience method for computing the absolute amplitude spectrum of a real signal.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#computeLogAmplitudeSpectrum_FD(double[])">computeLogAmplitudeSpectrum_FD</a></strong>(double[]&nbsp;fft)</code>
<div class="block">From the result of the FFT (in the frequency domain), compute the log amplitude for each positive frequency.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#computeLogAmplitudeSpectrum(double[])">computeLogAmplitudeSpectrum</a></strong>(double[]&nbsp;signal)</code>
<div class="block">Convenience method for computing the log amplitude spectrum of a real signal.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#computeLogPowerSpectrum_FD(double[])">computeLogPowerSpectrum_FD</a></strong>(double[]&nbsp;fft)</code>
<div class="block">From the result of the FFT, compute the log (dB) power for each positive frequency.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#computeLogPowerSpectrum(double[])">computeLogPowerSpectrum</a></strong>(double[]&nbsp;signal)</code>
<div class="block">Convenience method for computing the log (dB) power spectrum of a real signal.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#computePhaseSpectrum_FD(double[])">computePhaseSpectrum_FD</a></strong>(double[]&nbsp;fft)</code>
<div class="block">From the result of the FFT (in the frequency domain), compute the phase spectrum for each positive frequency.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#computePowerSpectrum_FD(double[])">computePowerSpectrum_FD</a></strong>(double[]&nbsp;fft)</code>
<div class="block">From the result of the FFT (in the frequency domain), compute the power for each positive frequency.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#computePowerSpectrum(double[])">computePowerSpectrum</a></strong>(double[]&nbsp;signal)</code>
<div class="block">Convenience method for computing the absolute power spectrum of a real signal.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#convolve_FD(double[],%20double[])">convolve_FD</a></strong>(double[]&nbsp;signal1,
           double[]&nbsp;fft2)</code>
<div class="block">Compute the convolution of two signals, by multiplying them in the frequency domain.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#convolve_FD(double[],%20double[],%20double)">convolve_FD</a></strong>(double[]&nbsp;signal1,
           double[]&nbsp;fft2,
           double&nbsp;deltaT)</code>
<div class="block">Compute the convolution of two signals, by multiplying them in the frequency domain.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#convolve(double[],%20double[])">convolve</a></strong>(double[]&nbsp;signal1,
        double[]&nbsp;signal2)</code>
<div class="block">Compute the convolution of two signals, by multiplying them in the frequency domain.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#convolve(double[],%20double[],%20double)">convolve</a></strong>(double[]&nbsp;signal1,
        double[]&nbsp;signal2,
        double&nbsp;deltaT)</code>
<div class="block">Compute the convolution of two signals, by multiplying them in the frequency domain.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#convolveWithZeroPadding(double[],%20double[])">convolveWithZeroPadding</a></strong>(double[]&nbsp;signal1,
                       double[]&nbsp;signal2)</code>
<div class="block">Compute the convolution of two signals, by multipying them in the frequency domain.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#convolveWithZeroPadding(double[],%20double[],%20double)">convolveWithZeroPadding</a></strong>(double[]&nbsp;signal1,
                       double[]&nbsp;signal2,
                       double&nbsp;deltaT)</code>
<div class="block">Compute the convolution of two signals, by multipying them in the frequency domain.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#correlate(double[],%20double[])">correlate</a></strong>(double[]&nbsp;signal1,
         double[]&nbsp;signal2)</code>
<div class="block">Compute the correlation of two signals, by multiplying the transform of signal2 with the conjugate complex of the transform
 of signal1, in the frequency domain.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#correlateWithZeroPadding(double[],%20double[])">correlateWithZeroPadding</a></strong>(double[]&nbsp;signal1,
                        double[]&nbsp;signal2)</code>
<div class="block">Compute the correlation of two signals, by multipying them in the frequency domain.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#main(java.lang.String[])">main</a></strong>(<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>[]&nbsp;args)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#realTransform(double[],%20boolean)">realTransform</a></strong>(double[]&nbsp;data,
             boolean&nbsp;inverse)</code>
<div class="block">Calculates the Fourier transform of a set of n real-valued data points.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#transform(double[],%20boolean)">transform</a></strong>(double[]&nbsp;realAndImag,
         boolean&nbsp;inverse)</code>
<div class="block">Carry out the FFT or inverse FFT, and return the result in the same arrays given as parameters.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../marytts/util/math/FFT.html#transform(double[],%20double[],%20boolean)">transform</a></strong>(double[]&nbsp;real,
         double[]&nbsp;imag,
         boolean&nbsp;inverse)</code>
<div class="block">Carry out the FFT or inverse FFT, and return the result in the same arrays given as parameters.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></h3>
<code><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#clone()" title="class or interface in java.lang">clone</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.lang">equals</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#finalize()" title="class or interface in java.lang">finalize</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#getClass()" title="class or interface in java.lang">getClass</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#hashCode()" title="class or interface in java.lang">hashCode</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#notify()" title="class or interface in java.lang">notify</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#notifyAll()" title="class or interface in java.lang">notifyAll</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#toString()" title="class or interface in java.lang">toString</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#wait()" title="class or interface in java.lang">wait</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#wait(long)" title="class or interface in java.lang">wait</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#wait(long,%20int)" title="class or interface in java.lang">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="FFT()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>FFT</h4>
<pre>public&nbsp;FFT()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="computeLogPowerSpectrum(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLogPowerSpectrum</h4>
<pre>public static&nbsp;double[]&nbsp;computeLogPowerSpectrum(double[]&nbsp;signal)</pre>
<div class="block">Convenience method for computing the log (dB) power spectrum of a real signal. The signal can be of any length; internally,
 zeroes will be added if signal length is not a power of two.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>signal</code> - the real signal for which to compute the power spectrum.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the power spectrum, as an array of length N/2 (where N is the power of two greater than or equal to signal.length):
         the log of the squared absolute values of the lower half of the complex fourier transform array.</dd></dl>
</li>
</ul>
<a name="computeLogPowerSpectrum_FD(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLogPowerSpectrum_FD</h4>
<pre>public static&nbsp;double[]&nbsp;computeLogPowerSpectrum_FD(double[]&nbsp;fft)</pre>
<div class="block">From the result of the FFT, compute the log (dB) power for each positive frequency.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>fft</code> - the array of real and imag parts of the complex number array, fft[0] = real[0], fft[1] = real[N/2], fft[2*i] =
            real[i], fft[2*i+1] = imag[i] for 1&le;i&lt;N/2</dd>
<dt><span class="strong">Returns:</span></dt><dd>an array of length real.length/2 containing numbers representing the log of the square of the absolute value of
         each complex number, p[i] = real[i]*real[i] + imag[i]*imag[i]</dd></dl>
</li>
</ul>
<a name="computePowerSpectrum(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computePowerSpectrum</h4>
<pre>public static&nbsp;double[]&nbsp;computePowerSpectrum(double[]&nbsp;signal)</pre>
<div class="block">Convenience method for computing the absolute power spectrum of a real signal. The signal can be of any length; internally,
 zeroes will be added if signal length is not a power of two.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>signal</code> - the real signal for which to compute the power spectrum.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the power spectrum, as an array of length N/2 (where N is the power of two greater than or equal to signal.length):
         the squared absolute values of the lower half of the complex fourier transform array.</dd></dl>
</li>
</ul>
<a name="computePowerSpectrum_FD(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computePowerSpectrum_FD</h4>
<pre>public static&nbsp;double[]&nbsp;computePowerSpectrum_FD(double[]&nbsp;fft)</pre>
<div class="block">From the result of the FFT (in the frequency domain), compute the power for each positive frequency.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>fft</code> - the array of real and imag parts of the complex number array, fft[0] = real[0], fft[1] = real[N/2], fft[2*i] =
            real[i], fft[2*i+1] = imag[i] for 1&le;i&lt;N/2</dd>
<dt><span class="strong">Returns:</span></dt><dd>an array of length real.length/2 containing numbers representing the square of the absolute value of each complex
         number, p[i] = real[i]*real[i] + imag[i]*imag[i]</dd></dl>
</li>
</ul>
<a name="computeLogAmplitudeSpectrum(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLogAmplitudeSpectrum</h4>
<pre>public static&nbsp;double[]&nbsp;computeLogAmplitudeSpectrum(double[]&nbsp;signal)</pre>
<div class="block">Convenience method for computing the log amplitude spectrum of a real signal. The signal can be of any length; internally,
 zeroes will be added if signal length is not a power of two.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>signal</code> - the real signal for which to compute the power spectrum.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the log amplitude spectrum, as an array of length N/2 (where N is the power of two greater than or equal to
         signal.length): the log of the absolute values of the lower half of the complex fourier transform array.</dd></dl>
</li>
</ul>
<a name="computeLogAmplitudeSpectrum_FD(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLogAmplitudeSpectrum_FD</h4>
<pre>public static&nbsp;double[]&nbsp;computeLogAmplitudeSpectrum_FD(double[]&nbsp;fft)</pre>
<div class="block">From the result of the FFT (in the frequency domain), compute the log amplitude for each positive frequency.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>fft</code> - the array of real and imag parts of the complex number array, fft[0] = real[0], fft[1] = real[N/2], fft[2*i] =
            real[i], fft[2*i+1] = imag[i] for 1&le;i&lt;N/2</dd>
<dt><span class="strong">Returns:</span></dt><dd>an array of length real.length/2 containing numbers representing the log of the square of the absolute value of
         each complex number, p[i] = real[i]*real[i] + imag[i]*imag[i]</dd></dl>
</li>
</ul>
<a name="computeAmplitudeSpectrum(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeAmplitudeSpectrum</h4>
<pre>public static&nbsp;double[]&nbsp;computeAmplitudeSpectrum(double[]&nbsp;signal)</pre>
<div class="block">Convenience method for computing the absolute amplitude spectrum of a real signal. The signal can be of any length;
 internally, zeroes will be added if signal length is not a power of two.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>signal</code> - the real signal for which to compute the power spectrum.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the power spectrum, as an array of length N/2 (where N is the power of two greater than or equal to signal.length):
         the absolute values of the lower half of the complex fourier transform array.</dd></dl>
</li>
</ul>
<a name="computeAmplitudeSpectrum_FD(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeAmplitudeSpectrum_FD</h4>
<pre>public static&nbsp;double[]&nbsp;computeAmplitudeSpectrum_FD(double[]&nbsp;fft)</pre>
<div class="block">From the result of the FFT (in the frequency domain), compute the absolute value for each positive frequency, i.e. the norm
 of each complex number in the lower half of the array</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>fft</code> - the array of real and imag parts of the complex number array, fft[0] = real[0], fft[1] = real[N/2], fft[2*i] =
            real[i], fft[2*i+1] = imag[i] for 1&le;i&lt;N/2</dd>
<dt><span class="strong">Returns:</span></dt><dd>an array of length real.length/2 containing numbers representing the absolute value of each complex number, r[i] =
         sqrt(real[i]*real[i] + imag[i]*imag[i])</dd></dl>
</li>
</ul>
<a name="computePhaseSpectrum_FD(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computePhaseSpectrum_FD</h4>
<pre>public static&nbsp;double[]&nbsp;computePhaseSpectrum_FD(double[]&nbsp;fft)</pre>
<div class="block">From the result of the FFT (in the frequency domain), compute the phase spectrum for each positive frequency.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>fft</code> - the array of real and imag parts of the complex number array, fft[0] = real[0], fft[1] = real[N/2], fft[2*i] =
            real[i], fft[2*i+1] = imag[i] for 1&le;i&lt;N/2</dd>
<dt><span class="strong">Returns:</span></dt><dd>an array of length real.length/2 containing numbers representing the phases of each complex number, phase[i] =
         atan(imag[i], real[i])</dd></dl>
</li>
</ul>
<a name="transform(double[], double[], boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transform</h4>
<pre>public static&nbsp;void&nbsp;transform(double[]&nbsp;real,
             double[]&nbsp;imag,
             boolean&nbsp;inverse)</pre>
<div class="block">Carry out the FFT or inverse FFT, and return the result in the same arrays given as parameters. In the case of the
 "forward" FFT, real is the signal to transform, and imag is an empty array. After the call, real will hold the real part of
 the complex frequency array, and imag will hold the imaginary part. They are ordered such that first come positive
 frequencies from 0 to fmax, then the negative frequencies from -fmax to 0 (which are the mirror image of the positive
 frequencies). In the case of the inverse FFT, real and imag are in input the real and imaginary part of the complex
 frequencies, and in output, real is the signal. The method already computes the division by array length required for the
 inverse transform.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>real</code> - in "forward" FFT: as input=the time-domain signal to transform, as output=the real part of the complex
            frequencies; in inverse FFT: as input=the real part of the complex frequencies, as output= the time-domain
            signal.</dd><dd><code>imag</code> - in "forward" FFT: as input=an empty array, as output=the imaginary part of the complex frequencies; in inverse
            FFT: as input=the imaginary part of the complex frequencies, as output= not used.</dd><dd><code>inverse</code> - whether to calculate the FFT or the inverse FFT.</dd></dl>
</li>
</ul>
<a name="transform(double[], boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transform</h4>
<pre>public static&nbsp;void&nbsp;transform(double[]&nbsp;realAndImag,
             boolean&nbsp;inverse)</pre>
<div class="block">Carry out the FFT or inverse FFT, and return the result in the same arrays given as parameters. This works exactly like
 #transform(real, imag, boolean), but data is represented differently: the even indices of the input array hold the real
 part, the odd indices the imag part of each complex number.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>realAndImag</code> - the array of complex numbers to transform</dd><dd><code>inverse</code> - whether to calculate the FFT or the inverse FFT.</dd></dl>
</li>
</ul>
<a name="realTransform(double[], boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>realTransform</h4>
<pre>public static&nbsp;void&nbsp;realTransform(double[]&nbsp;data,
                 boolean&nbsp;inverse)</pre>
<div class="block">Calculates the Fourier transform of a set of n real-valued data points. Replaces this data (which is stored in array
 data[1..n]) by the positive frequency half of its complex Fourier transform. The real-valued first and last components of
 the complex transform are returned as elements data[1] and data[2], respectively. n must be a power of 2. This routine also
 calculates the inverse transform of a complex data array if it is the transform of real data. (Result in this case must be
 multiplied by 2/n.)</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>data</code> - data</dd><dd><code>inverse</code> - inverse</dd></dl>
</li>
</ul>
<a name="convolveWithZeroPadding(double[], double[], double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convolveWithZeroPadding</h4>
<pre>public static&nbsp;double[]&nbsp;convolveWithZeroPadding(double[]&nbsp;signal1,
                               double[]&nbsp;signal2,
                               double&nbsp;deltaT)</pre>
<div class="block">Compute the convolution of two signals, by multipying them in the frequency domain. Normalise the result with respect to
 deltaT (the inverse of the sampling rate). This method applies zero padding where necessary to ensure that the result is
 not polluted because of assumed periodicity. The two signals need not be of equal length.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>signal1</code> - signal 1</dd><dd><code>signal2</code> - signal 2</dd><dd><code>deltaT</code> - , the time difference between two samples (= 1/samplingrate)</dd>
<dt><span class="strong">Returns:</span></dt><dd>the convolved signal, with length signal1.length+signal2.length</dd></dl>
</li>
</ul>
<a name="convolveWithZeroPadding(double[], double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convolveWithZeroPadding</h4>
<pre>public static&nbsp;double[]&nbsp;convolveWithZeroPadding(double[]&nbsp;signal1,
                               double[]&nbsp;signal2)</pre>
<div class="block">Compute the convolution of two signals, by multipying them in the frequency domain. This method applies zero padding where
 necessary to ensure that the result is not polluted because of assumed periodicity. The two signals need not be of equal
 length.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>signal1</code> - signal 1</dd><dd><code>signal2</code> - signal 2</dd>
<dt><span class="strong">Returns:</span></dt><dd>the convolved signal, with length signal1.length+signal2.length</dd></dl>
</li>
</ul>
<a name="convolve(double[], double[], double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convolve</h4>
<pre>public static&nbsp;double[]&nbsp;convolve(double[]&nbsp;signal1,
                double[]&nbsp;signal2,
                double&nbsp;deltaT)</pre>
<div class="block">Compute the convolution of two signals, by multiplying them in the frequency domain. Normalise the result with respect to
 deltaT (the inverse of the sampling rate). This is the core method, requiring two signals of equal length, which must be a
 power of two, and not checking for pollution arising from the assumed periodicity of both signals.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>signal1</code> - signal 1</dd><dd><code>signal2</code> - signal 2</dd><dd><code>deltaT</code> - , the time difference between two samples (= 1/samplingrate)</dd>
<dt><span class="strong">Returns:</span></dt><dd>the convolved signal, of the same length as the two input signals</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</a></code> - if the two input signals do not have the same length.</dd></dl>
</li>
</ul>
<a name="convolve(double[], double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convolve</h4>
<pre>public static&nbsp;double[]&nbsp;convolve(double[]&nbsp;signal1,
                double[]&nbsp;signal2)</pre>
<div class="block">Compute the convolution of two signals, by multiplying them in the frequency domain. This is the core method, requiring two
 signals of equal length, which must be a power of two, and not checking for pollution arising from the assumed periodicity
 of both signals.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>signal1</code> - signal 1</dd><dd><code>signal2</code> - signal 2</dd>
<dt><span class="strong">Returns:</span></dt><dd>the convolved signal, of the same length as the two input signals</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</a></code> - if the two input signals do not have the same length.</dd></dl>
</li>
</ul>
<a name="convolve_FD(double[], double[], double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convolve_FD</h4>
<pre>public static&nbsp;double[]&nbsp;convolve_FD(double[]&nbsp;signal1,
                   double[]&nbsp;fft2,
                   double&nbsp;deltaT)</pre>
<div class="block">Compute the convolution of two signals, by multiplying them in the frequency domain. Normalise the result with respect to
 deltaT (the inverse of the sampling rate). This is a specialised version of the core method, requiring two signals of equal
 length, which must be a power of two, and not checking for pollution arising from the assumed periodicity of both signals.
 In this version, the first signal is provided in the time domain, while the second is already transformed into the
 frequency domain.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>signal1</code> - the first input signal, in the time domain</dd><dd><code>fft2</code> - the complex transform of the second signal, in the frequency domain fft[0] = real[0], fft[1] = real[N/2],
            fft[2*i] = real[i], fft[2*i+1] = imag[i] for 1&le;i&lt;N/2</dd><dd><code>deltaT</code> - , the time difference between two samples (= 1/samplingrate)</dd>
<dt><span class="strong">Returns:</span></dt><dd>the convolved signal, of the same length as the two input signals</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</a></code> - if the two input signals do not have the same length.</dd></dl>
</li>
</ul>
<a name="convolve_FD(double[], double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convolve_FD</h4>
<pre>public static&nbsp;double[]&nbsp;convolve_FD(double[]&nbsp;signal1,
                   double[]&nbsp;fft2)</pre>
<div class="block">Compute the convolution of two signals, by multiplying them in the frequency domain. This is a specialised version of the
 core method, requiring two signals of equal length, which must be a power of two, and not checking for pollution arising
 from the assumed periodicity of both signals. In this version, the first signal is provided in the time domain, while the
 second is already transformed into the frequency domain.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>signal1</code> - the first input signal, in the time domain</dd><dd><code>fft2</code> - the complex transform of the second signal, in the frequency domain fft[0] = real[0], fft[1] = real[N/2],
            fft[2*i] = real[i], fft[2*i+1] = imag[i] for 1&le;i&lt;N/2</dd>
<dt><span class="strong">Returns:</span></dt><dd>the convolved signal, of the same length as the two input signals</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</a></code> - if the two input signals do not have the same length.</dd></dl>
</li>
</ul>
<a name="correlateWithZeroPadding(double[], double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>correlateWithZeroPadding</h4>
<pre>public static&nbsp;double[]&nbsp;correlateWithZeroPadding(double[]&nbsp;signal1,
                                double[]&nbsp;signal2)</pre>
<div class="block">Compute the correlation of two signals, by multipying them in the frequency domain. This method applies zero padding where
 necessary to ensure that the result is not polluted because of assumed periodicity. The two signals need not be of equal
 length.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>signal1</code> - signal 1</dd><dd><code>signal2</code> - signal 2</dd>
<dt><span class="strong">Returns:</span></dt><dd>the correlation function, with length signal1.length+signal2.length</dd></dl>
</li>
</ul>
<a name="correlate(double[], double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>correlate</h4>
<pre>public static&nbsp;double[]&nbsp;correlate(double[]&nbsp;signal1,
                 double[]&nbsp;signal2)</pre>
<div class="block">Compute the correlation of two signals, by multiplying the transform of signal2 with the conjugate complex of the transform
 of signal1, in the frequency domain. Sign convention: If signal2 is shifted by n to the right of signal2, then the
 correlation function will have a peak at positive n. This is the core method, requiring two signals of equal length, which
 must be a power of two, and not checking for pollution arising from the assumed periodicity of both signals.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>signal1</code> - signal 1</dd><dd><code>signal2</code> - signal 2</dd>
<dt><span class="strong">Returns:</span></dt><dd>the correlated signal, of the same length as the two input signals</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</a></code> - if the two input signals do not have the same length.</dd></dl>
</li>
</ul>
<a name="autoCorrelate(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>autoCorrelate</h4>
<pre>public static&nbsp;double[]&nbsp;autoCorrelate(double[]&nbsp;signal)</pre>
<div class="block">Compute the autocorrelation of a signal, by inverse transformation of its power spectrum. This is the core method,
 requiring a signal whose length must be a power of two, and not checking for pollution arising from the assumed periodicity
 of the signal.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>signal</code> - signal</dd>
<dt><span class="strong">Returns:</span></dt><dd>the correlated signal, of the same length as the input signal</dd></dl>
</li>
</ul>
<a name="autoCorrelateWithZeroPadding(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>autoCorrelateWithZeroPadding</h4>
<pre>public static&nbsp;double[]&nbsp;autoCorrelateWithZeroPadding(double[]&nbsp;signal)</pre>
<div class="block">Compute the autocorrelation of a signal, by inverse transformation of its power spectrum. This method applies zero padding
 where necessary to ensure that the result is not polluted because of assumed periodicity.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>signal</code> - signal</dd>
<dt><span class="strong">Returns:</span></dt><dd>the correlated signal, of the same length as the input signal</dd></dl>
</li>
</ul>
<a name="main(java.lang.String[])">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>main</h4>
<pre>public static&nbsp;void&nbsp;main(<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>[]&nbsp;args)
                 throws <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html?is-external=true" title="class or interface in java.lang">Exception</a></pre>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html?is-external=true" title="class or interface in java.lang">Exception</a></code></dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/FFT.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../marytts/util/math/DTW.RecurssiveDTW.html" title="class in marytts.util.math"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../marytts/util/math/FFTMixedRadix.html" title="class in marytts.util.math"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?marytts/util/math/FFT.html" target="_top">Frames</a></li>
<li><a href="FFT.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2000&#x2013;2015 <a href="http://www.dfki.de/">DFKI GmbH</a>. All rights reserved.</small></p>
</body>
</html>
